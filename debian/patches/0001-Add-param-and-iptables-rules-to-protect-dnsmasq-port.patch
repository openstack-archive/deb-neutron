Description: Add param and iptables rules to protect dnsmasq ports
 Add a param to the configuration file of the dhcp agent. With this new param
 set as true, iptables rules are inserted to limit dns requests to dnsmasq only
 to the client which are on the same subnet.
Author: Sylvain Afchain <sylvain.afchain@enovance.com>
Date: Thu, 12 Dec 2013 23:20:17 +0100
Origin: upstream, https://review.openstack.org/61994
Bug-Ubuntu: https://bugs.launchpad.net/neutron/+bug/1260731

--- a/etc/dhcp_agent.ini
+++ b/etc/dhcp_agent.ini
@@ -70,3 +70,8 @@
 
 # Location of Metadata Proxy UNIX domain socket
 # metadata_proxy_socket = $state_path/metadata_proxy
+
+# Limits the dns requests to dnsmasq only to clients which are on its subnet.
+# Useful when a subnet is routed to another one or in the case of an
+# external network.
+# isolate_dns_requests = False
--- a/neutron/agent/linux/dhcp.py
+++ b/neutron/agent/linux/dhcp.py
@@ -28,6 +28,7 @@ import netaddr
 from oslo.config import cfg
 
 from neutron.agent.linux import ip_lib
+from neutron.agent.linux import iptables_manager
 from neutron.agent.linux import utils
 from neutron.common import constants
 from neutron.common import exceptions
@@ -57,6 +58,9 @@ OPTS = [
         help=_('Limit number of leases to prevent a denial-of-service.')),
     cfg.StrOpt('interface_driver',
                help=_("The driver used to manage the virtual interface.")),
+    cfg.BoolOpt('isolate_dns_requests', default=False,
+                help=_("Allow dns requests to dnsmasq only from clients "
+                       "on its subnet.")),
 ]
 
 IPV4 = 4
@@ -562,7 +566,28 @@ class Dnsmasq(DhcpLocalProcess):
             sock.close()
 
 
+class NamespaceIptablesManagerCache(object):
+    def __init__(self):
+        self.iptables_managers = {}
+
+    def get_or_create(self, namespace, root_helper):
+        ns = namespace or 'none'
+
+        im = self.iptables_managers.get(ns)
+        if not im:
+            im = iptables_manager.IptablesManager(
+                root_helper=root_helper,
+                namespace=namespace)
+            self.iptables_managers[ns] = im
+
+        return im
+
+    def get(self, namespace):
+        return self.iptables_managers.get(namespace or 'none')
+
+
 class DeviceManager(object):
+    iptables_ns_manager = NamespaceIptablesManagerCache()
 
     def __init__(self, conf, root_helper, plugin):
         self.conf = conf
@@ -700,6 +725,85 @@ class DeviceManager(object):
 
         return dhcp_port
 
+    def _get_interface_name_from_network(self, network):
+        device_id = self.get_device_id(network)
+        port = self.plugin.get_dhcp_port(network.id, device_id)
+        if port:
+            interface_name = self.get_interface_name(network, port)
+        else:
+            raise exceptions.NetworkNotFound(net_id=network.id)
+
+        return interface_name
+
+    @staticmethod
+    def _get_isolation_rule(proto, chain, interface):
+        return ('-p %(proto)s -m %(proto)s '
+                '--dport 53 -i %(interface)s '
+                '-j $%(chain)s') % {'proto': proto,
+                                    'chain': chain,
+                                    'interface': interface}
+
+    def _remove_dns_isolation(self, network):
+        interface_name = self._get_interface_name_from_network(network)
+
+        im = DeviceManager.iptables_ns_manager.get(network.namespace)
+        if not im:
+            LOG.error(_("Error unable get the iptables manager created "
+                        "for network %s"), network.id)
+            return
+
+        rules_chain = iptables_manager.get_chain_name(
+            "dns-" + network.id)
+
+        for tables in [im.ipv4, im.ipv6]:
+            for proto in ['udp', 'tcp']:
+                rule = self._get_isolation_rule(proto, rules_chain,
+                                                interface_name)
+                tables['filter'].remove_rule('INPUT', rule)
+
+            tables['filter'].remove_chain(rules_chain)
+
+        im.apply()
+
+    def _apply_dns_isolation(self, network, interface_name=None):
+        if not interface_name:
+            interface_name = self._get_interface_name_from_network(network)
+
+        im = DeviceManager.iptables_ns_manager.get_or_create(network.namespace,
+                                                             self.root_helper)
+        if not im:
+            LOG.error(_("Error unable to create or get an iptables manager "
+                        "for network %s"), network.id)
+            return
+
+        rules_chain = iptables_manager.get_chain_name(
+            "dns-" + network.id)
+
+        for tables in [im.ipv4, im.ipv6]:
+            tables['filter'].add_chain(rules_chain)
+            tables['filter'].empty_chain(rules_chain)
+            tables['filter'].add_rule(rules_chain, '-j DROP')
+
+            for proto in ['udp', 'tcp']:
+                rule = self._get_isolation_rule(proto, rules_chain,
+                                                interface_name)
+                tables['filter'].add_rule('INPUT', rule)
+
+        # allow traffic from subnets everything else will be denied
+        for subnet in network.subnets:
+            if not subnet.enable_dhcp:
+                continue
+
+            tables = im.ipv4
+            if subnet.ip_version != 4:
+                tables = im.ipv6
+
+            rule = '-s ' + subnet.cidr + ' -j RETURN'
+            tables['filter'].add_rule(rules_chain,
+                                      rule, top=True)
+
+        im.apply()
+
     def setup(self, network, reuse_existing=False):
         """Create and initialize a device for network's DHCP on this host."""
         port = self.setup_dhcp_port(network)
@@ -742,6 +846,9 @@ class DeviceManager(object):
         if self.conf.use_namespaces:
             self._set_default_route(network)
 
+        if self.conf.isolate_dns_requests:
+            self._apply_dns_isolation(network, interface_name)
+
         return interface_name
 
     def update(self, network):
@@ -749,8 +856,14 @@ class DeviceManager(object):
         if self.conf.use_namespaces:
             self._set_default_route(network)
 
+        if self.conf.isolate_dns_requests:
+            self._apply_dns_isolation(network)
+
     def destroy(self, network, device_name):
         """Destroy the device used for the network's DHCP on this host."""
+        if self.conf.isolate_dns_requests:
+            self._remove_dns_isolation(network)
+
         self.driver.unplug(device_name, namespace=network.namespace)
 
         self.plugin.release_dhcp_port(network.id,
--- a/neutron/tests/unit/test_linux_dhcp.py
+++ b/neutron/tests/unit/test_linux_dhcp.py
@@ -15,6 +15,7 @@
 #    License for the specific language governing permissions and limitations
 #    under the License.
 
+import contextlib
 import os
 
 import mock
@@ -23,6 +24,7 @@ from oslo.config import cfg
 from neutron.agent.common import config
 from neutron.agent.linux import dhcp
 from neutron.common import config as base_config
+from neutron.common import exceptions
 from neutron.openstack.common import log as logging
 from neutron.tests import base
 
@@ -339,6 +341,8 @@ class TestBase(base.BaseTestCase):
         self.conf.register_opts(dhcp.OPTS)
         instance = mock.patch("neutron.agent.linux.dhcp.DeviceManager")
         self.mock_mgr = instance.start()
+        self.device_mock = mock.patch("neutron.agent.linux.dhcp.DeviceManager")
+        self.mock_mgr = self.device_mock.start()
         self.addCleanup(self.mock_mgr.stop)
         self.conf.register_opt(cfg.BoolOpt('enable_isolated_metadata',
                                            default=True))
@@ -478,6 +482,270 @@ class TestDhcpLocalProcess(TestBase):
             self.assertEqual(lp.called, ['spawn'])
             self.assertTrue(mocks['interface_name'].__set__.called)
 
+    def test_namespace_iptables_manager_cache(self):
+        im_cache = dhcp.NamespaceIptablesManagerCache()
+        im1 = im_cache.get_or_create('abc', 'sudo')
+        self.assertNotEqual(im1, None)
+
+        im = im_cache.get_or_create('abc', 'sudo')
+        self.assertEqual(im, im1)
+
+        im2 = im_cache.get_or_create('def', 'sudo')
+        self.assertNotEqual(im2, None)
+        self.assertNotEqual(im1, im2)
+
+        im = im_cache.get('abc')
+        self.assertEqual(im, im1)
+        im = im_cache.get('def')
+        self.assertEqual(im, im2)
+        im = im_cache.get('ghi')
+        self.assertEqual(im, None)
+
+    def test_apply_dns_isolation_non_existing_port(self):
+        self.device_mock.stop()
+        self.conf.set_override('interface_driver',
+                               'neutron.agent.linux.interface.'
+                               'OVSInterfaceDriver')
+
+        iptables_inst = mock.Mock()
+        v4filter_inst = mock.Mock()
+        v6filter_inst = mock.Mock()
+        v4filter_inst.chains = []
+        v6filter_inst.chains = []
+        iptables_inst.ipv4 = {'filter': v4filter_inst}
+        iptables_inst.ipv6 = {'filter': v6filter_inst}
+
+        plugin_inst = mock.Mock()
+
+        with contextlib.nested(mock.patch('neutron.agent.linux.interface.'
+                                          'OVSInterfaceDriver'),
+                               mock.patch('neutron.agent.linux.'
+                                          'iptables_manager.IptablesManager',
+                                          return_value=iptables_inst),
+                               mock.patch('neutron.agent.linux.dhcp.'
+                                          'DeviceManager.iptables_ns_manager')
+                               ) as (ovs_driver, ipm, ipm_ns):
+            ipm_ns.get_or_create.return_value = iptables_inst
+            ipm_ns.get.return_value = iptables_inst
+
+            device_mng = dhcp.DeviceManager(self.conf,
+                                            'sudo', plugin_inst)
+            device_mng.driver.get_device_name.return_value = 'tap123'
+            plugin_inst.get_dhcp_port.return_value = None
+
+            self.assertRaises(exceptions.NetworkNotFound,
+                              device_mng._apply_dns_isolation,
+                              FakeV4Network)
+
+            self.assertFalse(v4filter_inst.called)
+            self.assertFalse(v6filter_inst.called)
+
+    def test_apply_dns_isolation(self):
+        self.device_mock.stop()
+        self.conf.set_override('interface_driver',
+                               'neutron.agent.linux.interface.'
+                               'OVSInterfaceDriver')
+
+        iptables_inst = mock.Mock()
+        v4filter_inst = mock.Mock()
+        v6filter_inst = mock.Mock()
+        v4filter_inst.chains = []
+        v6filter_inst.chains = []
+        iptables_inst.ipv4 = {'filter': v4filter_inst}
+        iptables_inst.ipv6 = {'filter': v6filter_inst}
+
+        plugin_inst = mock.Mock()
+
+        with contextlib.nested(mock.patch('neutron.agent.linux.interface.'
+                                          'OVSInterfaceDriver'),
+                               mock.patch('neutron.agent.linux.'
+                                          'iptables_manager.IptablesManager',
+                                          return_value=iptables_inst),
+                               mock.patch('neutron.agent.linux.dhcp.'
+                                          'DeviceManager.iptables_ns_manager')
+                               ) as (ovs_driver, ipm, ipm_ns):
+            ipm_ns.get_or_create.return_value = iptables_inst
+            ipm_ns.get.return_value = iptables_inst
+
+            device_mng = dhcp.DeviceManager(self.conf,
+                                            'sudo', plugin_inst)
+            device_mng.driver.get_device_name.return_value = 'tap123'
+            device_mng._apply_dns_isolation(FakeV4Network)
+
+            callsv4 = [mock.call.add_chain('dns-aaaaaaa'),
+                       mock.call.empty_chain('dns-aaaaaaa'),
+                       mock.call.add_rule('dns-aaaaaaa', '-j DROP'),
+                       mock.call.add_rule('INPUT', '-p udp -m udp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-aaaaaaa'),
+                       mock.call.add_rule('INPUT', '-p tcp -m tcp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-aaaaaaa'),
+                       mock.call.add_rule('dns-aaaaaaa',
+                                          '-s 192.168.0.0/24 '
+                                          '-j RETURN', top=True)]
+            v4filter_inst.assert_has_calls(callsv4)
+
+            callsv6 = [mock.call.add_chain('dns-aaaaaaa'),
+                       mock.call.empty_chain('dns-aaaaaaa'),
+                       mock.call.add_rule('dns-aaaaaaa', '-j DROP'),
+                       mock.call.add_rule('INPUT', '-p udp -m udp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-aaaaaaa'),
+                       mock.call.add_rule('INPUT', '-p tcp -m tcp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-aaaaaaa')]
+            v6filter_inst.assert_has_calls(callsv6)
+
+            v4filter_inst.reset_mock()
+            v6filter_inst.reset_mock()
+
+            device_mng._apply_dns_isolation(FakeV6Network)
+
+            callsv4 = [mock.call.add_chain('dns-bbbbbbb'),
+                       mock.call.empty_chain('dns-bbbbbbb'),
+                       mock.call.add_rule('dns-bbbbbbb', '-j DROP'),
+                       mock.call.add_rule('INPUT', '-p udp -m udp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-bbbbbbb'),
+                       mock.call.add_rule('INPUT', '-p tcp -m tcp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-bbbbbbb')]
+            v4filter_inst.assert_has_calls(callsv4)
+
+            callsv6 = [mock.call.add_chain('dns-bbbbbbb'),
+                       mock.call.empty_chain('dns-bbbbbbb'),
+                       mock.call.add_rule('dns-bbbbbbb', '-j DROP'),
+                       mock.call.add_rule('INPUT', '-p udp -m udp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-bbbbbbb'),
+                       mock.call.add_rule('INPUT', '-p tcp -m tcp '
+                                          '--dport 53 -i tap123 '
+                                          '-j $dns-bbbbbbb'),
+                       mock.call.add_rule('dns-bbbbbbb',
+                                          '-s fdca:3ba5:a17a:4ba3::/64'
+                                          ' -j RETURN', top=True)]
+            v6filter_inst.assert_has_calls(callsv6)
+
+    def test_dns_isolation_non_existing_port(self):
+        self.device_mock.stop()
+        self.conf.set_override('interface_driver',
+                               'neutron.agent.linux.interface.'
+                               'OVSInterfaceDriver')
+
+        iptables_inst = mock.Mock()
+        v4filter_inst = mock.Mock()
+        v6filter_inst = mock.Mock()
+        v4filter_inst.chains = []
+        v6filter_inst.chains = []
+        iptables_inst.ipv4 = {'filter': v4filter_inst}
+        iptables_inst.ipv6 = {'filter': v6filter_inst}
+
+        plugin_inst = mock.Mock()
+
+        with contextlib.nested(mock.patch('neutron.agent.linux.interface.'
+                                          'OVSInterfaceDriver'),
+                               mock.patch('neutron.agent.linux.'
+                                          'iptables_manager.IptablesManager',
+                                          return_value=iptables_inst),
+                               mock.patch('neutron.agent.linux.dhcp.'
+                                          'DeviceManager.iptables_ns_manager')
+                               ) as (ovs_driver, ipm, ipm_ns):
+            ipm_ns.get_or_create.return_value = iptables_inst
+            ipm_ns.get.return_value = iptables_inst
+
+            device_mng = dhcp.DeviceManager(self.conf,
+                                            'sudo', plugin_inst)
+            device_mng.driver.get_device_name.return_value = 'tap123'
+            plugin_inst.get_dhcp_port.return_value = None
+
+            self.assertRaises(exceptions.NetworkNotFound,
+                              device_mng._apply_dns_isolation,
+                              FakeV4Network)
+
+            self.assertFalse(v4filter_inst.called)
+            self.assertFalse(v6filter_inst.called)
+
+            self.assertRaises(exceptions.NetworkNotFound,
+                              device_mng._remove_dns_isolation,
+                              FakeV4Network)
+
+            self.assertFalse(v4filter_inst.called)
+            self.assertFalse(v6filter_inst.called)
+
+    def test_remove_dns_isolation(self):
+        self.device_mock.stop()
+        self.conf.set_override('interface_driver',
+                               'neutron.agent.linux.interface.'
+                               'OVSInterfaceDriver')
+
+        iptables_inst = mock.Mock()
+        v4filter_inst = mock.Mock()
+        v6filter_inst = mock.Mock()
+        v4filter_inst.chains = []
+        v6filter_inst.chains = []
+        iptables_inst.ipv4 = {'filter': v4filter_inst}
+        iptables_inst.ipv6 = {'filter': v6filter_inst}
+
+        plugin_inst = mock.Mock()
+
+        with contextlib.nested(mock.patch('neutron.agent.linux.interface.'
+                                          'OVSInterfaceDriver'),
+                               mock.patch('neutron.agent.linux.'
+                                          'iptables_manager.IptablesManager',
+                                          return_value=iptables_inst),
+                               mock.patch('neutron.agent.linux.dhcp.'
+                                          'DeviceManager.iptables_ns_manager')
+                               ) as (ovs_driver, ipm, ipm_ns):
+            ipm_ns.get_or_create.return_value = iptables_inst
+            ipm_ns.get.return_value = iptables_inst
+
+            device_mng = dhcp.DeviceManager(self.conf,
+                                            'sudo', plugin_inst)
+            device_mng.driver.get_device_name.return_value = 'tap123'
+            device_mng._remove_dns_isolation(FakeV4Network)
+
+            callsv4 = [mock.call.remove_rule('INPUT', '-p udp -m udp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-aaaaaaa'),
+                       mock.call.remove_rule('INPUT', '-p tcp -m tcp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-aaaaaaa'),
+                       mock.call.remove_chain('dns-aaaaaaa')]
+            v4filter_inst.assert_has_calls(callsv4)
+
+            callsv6 = [mock.call.remove_rule('INPUT', '-p udp -m udp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-aaaaaaa'),
+                       mock.call.remove_rule('INPUT', '-p tcp -m tcp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-aaaaaaa'),
+                       mock.call.remove_chain('dns-aaaaaaa')]
+            v6filter_inst.assert_has_calls(callsv6)
+
+            v4filter_inst.reset_mock()
+            v6filter_inst.reset_mock()
+
+            device_mng._remove_dns_isolation(FakeV6Network)
+
+            callsv4 = [mock.call.remove_rule('INPUT', '-p udp -m udp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-bbbbbbb'),
+                       mock.call.remove_rule('INPUT', '-p tcp -m tcp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-bbbbbbb'),
+                       mock.call.remove_chain('dns-bbbbbbb')]
+            v4filter_inst.assert_has_calls(callsv4)
+
+            callsv6 = [mock.call.remove_rule('INPUT', '-p udp -m udp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-bbbbbbb'),
+                       mock.call.remove_rule('INPUT', '-p tcp -m tcp '
+                                             '--dport 53 -i tap123 '
+                                             '-j $dns-bbbbbbb'),
+                       mock.call.remove_chain('dns-bbbbbbb')]
+            v6filter_inst.assert_has_calls(callsv6)
+
     def test_disable_not_active(self):
         attrs_to_mock = dict([(a, mock.DEFAULT) for a in
                               ['active', 'interface_name', 'pid']])
